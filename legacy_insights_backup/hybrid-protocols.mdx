---
title: "Hybrid Protocols: HTTP, WebSocket & TCP"
summary: "Designing a robust communication layer for trading systems by combining the best of all worlds."
date: "Sep 10, 2024"
tags: ["Network", "System Design", "WebSockets"]
category: "Network"
image: "https://placehold.co/1200x600/0f172a/a78bfa?text=Hybrid+Architecture"
author: "Hardi Hsu"
---

A trading system isn't just one pipe; it's a complex network topology. We adopted a hybrid protocol architecture to balance reliability, speed, and standard compliance.

### The Core Triad

1.  **HTTP (REST)**: Management Layer.
    *   *Usage*: User Login, History Reports, Settings, Static Data.
    *   *Why*: Reliability and Caching are more important here than raw speed. It's stateless and cache-friendly.

2.  **WebSocket**: The Live Pulse.
    *   *Usage*: Real-time Market Data, Order Status Updates.
    *   *Why*: Persistent connection eliminates the HTTP handshake overhead. Essential for "Push" notifications.

3.  **TCP / IPC**: The Gateway Backbone.
    *   *Usage*: Internal communication between the Matching Engine and the Gateway.
    *   *Why*: Maximum throughput, minimal overhead.

### Managing State Across Protocols

One of the biggest challenges in a hybrid system is keeping the "Snapshot" (HTTP) consistent with the "Stream" (WebSocket).

**The Sequence ID Strategy**:
Every event in the system (e.g., An order fill) is assigned a strictly increasing Sequence ID (101, 102, 103...).

1.  User loads page (HTTP): Fetches Order History. Latest SeqID = **100**.
2.  WebSocket connects: Subscribes to updates.
3.  WebSocket receives usage: "Order Filled. SeqID = **102**".
4.  **Gap Detection**: Frontend notices it missed SeqID **101**. It (or the socket lib) immediately requests a "Gap Fill" for 101.

This ensures that even if the network fluctuates when switching from REST to Socket, the user's view of their account remains mathematically consistent.

### The "Heartbeat" Strategy

Mobile networks are unreliable. We implemented an application-level Heartbeat (Ping/Pong) every 3 seconds.

*   If the frontend misses 2 Pongs, it enters "Reconnecting" mode.
*   Outgoing orders are queued locally in Redux/Zustand.
*   Upon reconnection, the queue is flushed (with a validity check) to ensure no user intent is lost during a brief tunnel outage.
